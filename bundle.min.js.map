{"version":3,"file":"bundle.min.js","sources":["src/areWeDoneYet.ts","src/getBlockIndex.ts","src/parseCellGroup.ts","src/getUnique.ts","src/iterateCoords.ts","src/iterateChanges.ts","src/types.ts","src/main.ts"],"sourcesContent":["import { Changes, PossibleValuesCollection, Sudoku } from './types';\n\nexport default ((s: Sudoku) : boolean => s.matrix.every(row => row.every(Number.isInteger)));\n","import { Coordinate, Sudoku } from './types';\n\nexport default ((s: Sudoku, coord: Coordinate) : number => {\n  const bx = 0 | coord[0] / s.blockSize;\n  const by = 0 | coord[1] / s.blockSize;\n  return parseInt(`${by}${bx}`, s.blockSize);\n});\n","import { CellGroup, Sudoku } from './types';\n\nexport default ((s: Sudoku, identifier: string) : CellGroup => {\n  const id = identifier.split(':');\n  return s[`${id[0]}s`][id[1]];\n});\n","import getBlockIndex from './getBlockIndex';\nimport parseCellGroup from './parseCellGroup';\nimport { Changes, Coordinate, PossibleValues, Sudoku } from './types';\n\ninterface Option {\n  coord: Coordinate,\n  num: number\n}\n\nconst option = (coord: Coordinate, num: number) : Option => ({ coord, num });\n\nconst dedupeOptionsByNum = (options: Array<Option>) : Array<Option> => {\n  const seen: Map<number, number> = new Map(); // num to num\n  options.forEach(option => {\n    const { num } = option;\n    const seenNum = seen.get(num);\n    if (seenNum) {\n      seen.set(num, seenNum + 1);\n    } else {\n      seen.set(num, 1);\n    }\n  });\n  return options.filter(option => seen.get(option.num) === 1);\n};\n\nconst dedupeOptionsByCoord = (options: Array<Option>) : Array<Option> => {\n  const seen = new Map(); // [num, num] to num\n  options.forEach(option => {\n    const { coord } = option;\n    const seenCoord = seen.get(coord);\n    if (seenCoord) {\n      seen.set(coord, seenCoord + 1);\n    } else {\n      seen.set(coord, 1);\n    }\n  });\n  return options.filter(option => seen.get(option.coord) === 1);\n};\n\nconst place = (s: Sudoku) => (option: Option) : Changes => {\n  const [x, y] = option.coord;\n  const blockNum = getBlockIndex(s, option.coord);\n  const currentBlock = s.blocks[blockNum];\n  const currentCol = s.cols[x];\n  const currentRow = s.rows[y];\n  currentBlock.values.add(option.num);\n  currentCol.values.add(option.num);\n  currentRow.values.add(option.num);\n  s.matrix[y][x] = option.num;\n  return [`block:${blockNum}`, `col:${x}`, `row:${y}`];\n};\n\nconst getUnique = (s: Sudoku, pvals: PossibleValues) : Changes => {\n  const group = parseCellGroup(s, pvals.group);\n  const options: Option[] = pvals.values.reduce(\n    (ary: Array<Option>, vals: Array<number>, i: number) => ary.concat(\n      vals.map(\n        (val: number) : Option => option(group.coords[i], val))\n      ),\n      []\n    );\n  const placements = dedupeOptionsByNum(options).concat(dedupeOptionsByCoord(options));\n  return placements.map(place(s)).reduce((arr, v) => arr.concat(v), []);\n};\n\nexport default getUnique;\n","import getBlockIndex from './getBlockIndex';\nimport parseCellGroup from './parseCellGroup';\nimport { CellGroup, Coordinate, PossiVals, PossibleValues, Sudoku } from './types';\n\nexport default ((s: Sudoku, group: string) : PossibleValues => {\n  const cg = parseCellGroup(s, group);\n  const collectionOfPossiVals = cg.coords.map((coord: Coordinate) : PossiVals => {\n    const currentBlock = s.blocks[getBlockIndex(s, coord)];\n    const currentRow = s.rows[coord[1]];\n    const currentCol = s.cols[coord[0]];\n    const currentSet = new Set([...currentBlock.values, ...currentRow.values, ...currentCol.values]);\n    return s.allPossibleValues.filter((value) => !currentSet.has(value));\n    // There's no need to re-dedupe this since it was already deduped before\n  });\n  return ({\n    group,\n    values: collectionOfPossiVals,\n  });\n});\n","import areWeDoneYet from './areWeDoneYet';\nimport getUnique from './getUnique';\nimport iterateCoords from './iterateCoords';\nimport map from './map';\nimport pipe from './pipe';\nimport { Sudoku } from './types';\nexport default ((s: Sudoku) : void => {\n  s.changes = s.changes.map(change => getUnique(s, iterateCoords(s, change))).reduce((arr, v) => arr.concat(v), []);\n  if (s.changes.length < 1) {\n    // either we're done or something did a bad\n    if (areWeDoneYet(s)) {\n      throw Error('Nothing went wrong!');\n    } else {\n      throw Error('this sudoku is warm and bad');\n    }\n  }\n});\n","type CellGroupType = 'block'\n  | 'row'\n  | 'col';\ntype Matrix = Array<Array<number>>; // 0 = not filled in\nexport type PossiVals = Array<number>; // the possible values for one cell\nexport type Changes = Array<string>;\n// export interface Coordinate {\n//   [index: number]: number;\n// }\nexport type Coordinate = Array<number>;\nexport interface PossibleValues { // the possible values for an entire CellGroup\n  group: string;\n  values: Array<PossiVals>;\n}\nexport const makeCellGroupId = (type: CellGroupType, index: number) : string => `${type}:${index}`;\nexport const MatrixFactory = (size: number) : Matrix => Array(size).fill(0).map(() => Array(size).fill(null));\nexport class CellGroup {\n  identifier: string;\n  values: Set<number>;\n  coords: Array<Coordinate>\n  constructor(identifier: string, coords: Array<Coordinate>) {\n    return ({\n      identifier,\n      coords,\n      values: new Set(Array(coords.length).fill(0).map((v, i) => i)),\n    });\n  }\n}\nexport class Sudoku {\n  blockSize: number;\n  maxValue: number;\n  totalSize: number;\n  blocks: Array<CellGroup>;\n  rows: Array<CellGroup>;\n  cols: Array<CellGroup>;\n  changes: Changes;\n  matrix: Matrix;\n  allPossibleValues: Array<number>;\n\n  constructor(matrix: Matrix) {\n    const blockSize = Math.sqrt(matrix.length);\n    if (blockSize < 1 || !Number.isInteger(blockSize)) {\n      throw Error('The square root of the matrix length must be an integer larger than 0');\n    }\n    this.blockSize = blockSize;\n    this.maxValue = this.blockSize ** 2;\n    this.totalSize = this.blockSize ** 3;\n    this.changes = [];\n    const aryMaxVal = Array(this.maxValue).fill(0);\n    this.allPossibleValues\n\n    this.blocks = aryMaxVal.map((v, blockIdx) => {\n      const id = makeCellGroupId('block', blockIdx);\n      this.changes.push(id);\n      const block = Array(this.maxValue).fill(0).map((_, cellIdx) => [cellIdx % blockSize, 0 | cellIdx / blockSize]);\n      return new CellGroup(id, block);\n    });\n    this.rows = aryMaxVal.map((v, y) => {\n      const id = makeCellGroupId('row', y);\n      this.changes.push(id);\n      const row = aryMaxVal.map((_, x) => [x, y]);\n      return new CellGroup(id, row);\n    });\n    this.cols = aryMaxVal.map((v, x) => {\n      const id = makeCellGroupId('col', x);\n      this.changes.push(id);\n      const col = aryMaxVal.map((_, y) => [x, y]);\n      return new CellGroup(id, col);\n    });\n    this.matrix = matrix;\n    this.allPossibleValues = aryMaxVal.map((v, i) => i);\n  }\n}\n","export { default as iterateChanges } from './iterateChanges';\nimport { Sudoku, MatrixFactory } from './types';\nwindow.x = new Sudoku(MatrixFactory(9));\n"],"names":[],"mappings":";;;;AAEA,uBAAe,CAAC,UAAC,CAAS,IAAe,OAAA,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,UAAA,GAAG,IAAI,OAAA,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,GAAA,CAAC,GAAA,EAAE;;ACA7F,wBAAe,CAAC,UAAC,CAAS,EAAE,KAAiB;QAC3C,IAAM,EAAE,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC;QACtC,IAAM,EAAE,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,SAAS,CAAC;QACtC,OAAO,QAAQ,CAAC,KAAG,EAAE,GAAG,EAAI,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC;IAC7C,CAAC,EAAE;;ACJH,yBAAe,CAAC,UAAC,CAAS,EAAE,UAAkB;QAC5C,IAAM,EAAE,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACjC,OAAO,CAAC,EAAI,EAAE,CAAC,CAAC,CAAC,QAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC/B,CAAC,EAAE;;ICIH,IAAM,MAAM,GAAG,UAAC,KAAiB,EAAE,GAAW,IAAc,QAAC,EAAE,KAAK,EAAE,GAAG,EAAE,IAAC,CAAC;IAE7E,IAAM,kBAAkB,GAAG,UAAC,OAAsB;QAChD,IAAM,IAAI,GAAwB,IAAI,GAAG,EAAE,CAAC;QAC5C,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM;YACZ,oBAAG,CAAY;YACvB,IAAM,OAAO,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YAC9B,IAAI,OAAO,EAAE;gBACX,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,GAAG,CAAC,CAAC,CAAC;aAC5B;iBAAM;gBACL,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;aAClB;SACF,CAAC,CAAC;QACH,OAAO,OAAO,CAAC,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,GAAA,CAAC,CAAC;IAC9D,CAAC,CAAC;IAEF,IAAM,oBAAoB,GAAG,UAAC,OAAsB;QAClD,IAAM,IAAI,GAAG,IAAI,GAAG,EAAE,CAAC;QACvB,OAAO,CAAC,OAAO,CAAC,UAAA,MAAM;YACZ,wBAAK,CAAY;YACzB,IAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;YAClC,IAAI,SAAS,EAAE;gBACb,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,SAAS,GAAG,CAAC,CAAC,CAAC;aAChC;iBAAM;gBACL,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;aACpB;SACF,CAAC,CAAC;QACH,OAAO,OAAO,CAAC,MAAM,CAAC,UAAA,MAAM,IAAI,OAAA,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAA,CAAC,CAAC;IAChE,CAAC,CAAC;IAEF,IAAM,KAAK,GAAG,UAAC,CAAS,IAAK,OAAA,UAAC,MAAc;QAC1C,IAAA,iBAA2B,EAApB,SAAC,EAAE,SAAC,CAAiB;QAC5B,IAAM,QAAQ,GAAG,aAAa,CAAC,CAAC,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC;QAChD,IAAM,YAAY,GAAG,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QACxC,IAAM,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC7B,IAAM,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC7B,YAAY,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QACpC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QAClC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QAClC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC;QAC5B,OAAO,aAAU,QAAQ,aAAW,CAAC,aAAW,CAAC,EAAG,CAAC;IACvD,CAAC,GAAA,CAAC;IAEF,IAAM,SAAS,GAAG,UAAC,CAAS,EAAE,KAAqB;QACjD,IAAM,KAAK,GAAG,cAAc,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;QAC7C,IAAM,OAAO,GAAa,KAAK,CAAC,MAAM,CAAC,MAAM,CAC3C,UAAC,GAAkB,EAAE,IAAmB,EAAE,CAAS,IAAK,OAAA,GAAG,CAAC,MAAM,CAChE,IAAI,CAAC,GAAG,CACN,UAAC,GAAW,IAAc,OAAA,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,GAAA,CAAC,CACxD,GAAA,EACD,EAAE,CACH,CAAC;QACJ,IAAM,UAAU,GAAG,kBAAkB,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC;QACrF,OAAO,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,CAAC,IAAK,OAAA,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAA,EAAE,EAAE,CAAC,CAAC;IACxE,CAAC,CAAC;;AC3DF,wBAAe,CAAC,UAAC,CAAS,EAAE,KAAa;QACvC,IAAM,EAAE,GAAG,cAAc,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;QACpC,IAAM,qBAAqB,GAAG,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,UAAC,KAAiB;YAC5D,IAAM,YAAY,GAAG,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;YACvD,IAAM,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACpC,IAAM,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACpC,IAAM,UAAU,GAAG,IAAI,GAAG,CAAK,YAAY,CAAC,MAAM,QAAK,UAAU,CAAC,MAAM,EAAK,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;YACjG,OAAO,CAAC,CAAC,iBAAiB,CAAC,MAAM,CAAC,UAAC,KAAK,IAAK,OAAA,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,GAAA,CAAC,CAAC;;SAEtE,CAAC,CAAC;QACH,QAAQ;YACN,KAAK;YACL,MAAM,EAAE,qBAAqB;SAC9B,EAAE;IACL,CAAC,EAAE;;ACZH,yBAAe,CAAC,UAAC,CAAS;QACxB,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,UAAA,MAAM,IAAI,OAAA,SAAS,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,GAAA,CAAC,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,CAAC,IAAK,OAAA,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAA,EAAE,EAAE,CAAC,CAAC;QAClH,IAAI,CAAC,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;;YAExB,IAAI,YAAY,CAAC,CAAC,CAAC,EAAE;gBACnB,MAAM,KAAK,CAAC,qBAAqB,CAAC,CAAC;aACpC;iBAAM;gBACL,MAAM,KAAK,CAAC,6BAA6B,CAAC,CAAC;aAC5C;SACF;IACH,CAAC,EAAE;;ICFI,IAAM,eAAe,GAAG,UAAC,IAAmB,EAAE,KAAa,IAAc,QAAG,IAAI,SAAI,KAAK,IAAE,CAAC;AACnG,IAAO,IAAM,aAAa,GAAG,UAAC,IAAY,IAAc,OAAA,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,cAAM,OAAA,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAA,CAAC,GAAA,CAAC;IACvG;QAIL,mBAAY,UAAkB,EAAE,MAAyB;YACvD,QAAQ;gBACN,UAAU;gBACV,MAAM;gBACN,MAAM,EAAE,IAAI,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,GAAA,CAAC,CAAC;aAC/D,EAAE;SACJ;QACH,gBAAC;IAAD,CAAC,IAAA;IACM;QAWL,gBAAY,MAAc;YAXrB,iBA4CN;YAhCG,IAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAC3C,IAAI,SAAS,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE;gBACjD,MAAM,KAAK,CAAC,uEAAuE,CAAC,CAAC;aACtF;YACD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;YAC3B,IAAI,CAAC,QAAQ,GAAG,SAAA,IAAI,CAAC,SAAS,EAAI,CAAC,CAAA,CAAC;YACpC,IAAI,CAAC,SAAS,GAAG,SAAA,IAAI,CAAC,SAAS,EAAI,CAAC,CAAA,CAAC;YACrC,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;YAClB,IAAM,SAAS,GAAG,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAC/C,IAAI,CAAC,iBAAiB,CAAA;YAEtB,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,QAAQ;gBACtC,IAAM,EAAE,GAAG,eAAe,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;gBAC9C,KAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBACtB,IAAM,KAAK,GAAG,KAAK,CAAC,KAAI,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,OAAO,IAAK,OAAA,CAAC,OAAO,GAAG,SAAS,EAAE,CAAC,GAAG,OAAO,GAAG,SAAS,CAAC,GAAA,CAAC,CAAC;gBAC/G,OAAO,IAAI,SAAS,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;aACjC,CAAC,CAAC;YACH,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC;gBAC7B,IAAM,EAAE,GAAG,eAAe,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;gBACrC,KAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBACtB,IAAM,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,EAAE,CAAC,CAAC,GAAA,CAAC,CAAC;gBAC5C,OAAO,IAAI,SAAS,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC;aAC/B,CAAC,CAAC;YACH,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC;gBAC7B,IAAM,EAAE,GAAG,eAAe,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;gBACrC,KAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;gBACtB,IAAM,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,CAAC,EAAE,CAAC,CAAC,GAAA,CAAC,CAAC;gBAC5C,OAAO,IAAI,SAAS,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC;aAC/B,CAAC,CAAC;YACH,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;YACrB,IAAI,CAAC,iBAAiB,GAAG,SAAS,CAAC,GAAG,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,GAAA,CAAC,CAAC;SACrD;QACH,aAAC;IAAD,CAAC,IAAA;;ICtED,MAAM,CAAC,CAAC,GAAG,IAAI,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;;;;;;;;;;"}